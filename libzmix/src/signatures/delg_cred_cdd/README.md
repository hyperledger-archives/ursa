[Practical UC-Secure Delegatable Credentials with Attributes and Their Application to Blockchain](https://acmccs.github.io/papers/p683-camenischA.pdf)

**This implementation is not UC-secure but only implements the delegatable credential part**

### Brief description of the API
1. [Groth1 and Groth2 signatures](./groth_sig.rs).  
    - Parameters can be generated by calling `GrothS1::setup` or `GrothS2::setup`. `setup` takes the maximum number of attributes that need to be supported. Keep it one more than the number you want to support to accommodate the public key.
    - Signing keys can be generated by calling `GrothS1::keygen` or `GrothS2::keygen`. Takes the corresponding setup parameters.
    - A new signature can be created by calling `Groth1Sig:new` or `Groth2Sig:new`. An existing signature can be randomized by calling `randomize` on the siganture.
    - 2 methods for signature verification, `verify` and `verify_batch`, both with the same API. `verify` computes several pairings to verify the signature whereas `verify_batch` does only 1 big multi-pairing. Applies this observation to pairings: if it needs to be cheched that a == b and c == d and e == f, then choose a random number `r` and check whether (a-b) + (c-d)*r + (e-f)*r<sup>2</sup> == 0. Refer the docs for the method for more details     
2. [Issuers and delegation](./issuer.rs).  
   - Issuers are instantiated by calling `EvenLevelIssuer::new` or `OddLevelIssuer::new` by passing their level to the `new` function. Root issuers is at level 0 so always instantiated by `EvenLevelIssuer::new(0)`.
   - Issuers generate their keys with `EvenLevelIssuer::keygen` or `OddLevelIssuer::keygen`.
   - Issuers can delegate by calling `delegate` method that takes the attributes to sign, who to delegate to etc resulting in a credential. 
   - A credential is a called a link and the credentials issued by `EvenLevelIssuer`s are called `CredLinkOdd` and credentials issued by `OddLevelIssuer`s are called `CredLinkEven`.
   - A link stores its associated `level`, `attributes` and `signature`. The last element of `attributes` is the verification key of the delegatee and the signature is on `attributes`.
   - To verify the correctness of link, call `verify` on it with delegator public key, delegatee public key and setup params.    
   - The chain of credentials is kept in `CredChain` which internally has 2 lists, 1 for odd level links and 1 for even. Even or odd level links can be added by calling `extend_with_even` or `extend_with_odd` on the chain.
   - To verify that all delegations are valid in the chain, call `verify_delegations` on the chain. 
3. [Attribute tokens](./attribute_token.rs)  
   - Call `AttributeToken::new` with the `CredChain` and setup parameters to initialize attribute token generation.
   - Attribute tokens are generated for all levels of the given chain. To generate attribute token for a subset of the chain, first get a truncated version of the chain by
   calling `CredChain::get_truncated_chain` and then use that to create the attribute token. eg. if chain length is 10 and attribute token is 
   needed for the first 5 levels of the chain, get a truncated chain with `CredChain::get_truncated_chain(5)` and then use the result in `AttributeToken::new`     
   - Attribute token generation happens in 2 phases. In the commitment phase all commitments are generated and the response phase accepts the challenge. These are intentionally decoupled so that this can be used in a higher level protocol.
   - To generate the commitment, call `commitment` method with the indices of the revealed attributes at each level. The indices at each level are a set of integers.  
     The `commitment` method results in `AttributeTokenComm` object which can be converted to bytes by calling `to_bytes` so that those bytes can be used in challenge computation. Or for testing, `AttributeToken::gen_challenge` can be used that takes `AttributeTokenComm`
   - To generate response, call the `response`.
   - The verifies with then call `AttributeToken::reconstruct_commitment` to reconstruct the commitment that the prover would have created. He can now hash it into the challenge to compare with the prover's challenge.
   - Commitment computation can be sped up by using precomputation of some of the pairings. Precomputation can be done on the setup parameters which can be used for computing commitments 
    involving any `CredChain` or it can be done on signatures as well which makes those precomputations relevant to that `CredChain` only. 
    Thus the commitment can be created using 3 methods, either `AttributeToken::commitment` that does not accept any precomputation, 
    `AttributeToken::commitment_with_precomputation_on_setup_params` that only accepts precomputation done on setup params (using `PrecompOnSetupParams::new`) and 
    `AttributeToken::commitment_with_precomputation` that accepts precomputation done on setup params (using `PrecompOnSetupParams::new`) and on `CredChain` using `PrecompOnCredChain::new` 

Refer the tests to for details of the API. 

### Benchmarks
Tests print the timing of various operations. Run tests in release mode to get the timing information.

```
RUST_TEST_THREADS=1 cargo test --release -- --nocapture
```

### Pending
1. Add support for verifying the attribute token with a single multi-pairing as suggested in the TODO.